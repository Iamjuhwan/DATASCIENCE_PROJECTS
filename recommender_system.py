# -*- coding: utf-8 -*-
"""Recommender_system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O_XoMJrftRSg-Hg9cyzI9e0atZTrGO8y
"""

import pandas as pd
import random
import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
from sklearn.metrics.pairwise import cosine_similarity
import operator

from google.colab import drive
drive.mount('/content/drive')

# Load the anime dataset
anime = pd.read_csv('/content/drive/MyDrive/archive (1)/anime.csv')
anime.head()

rating = pd.read_csv('/content/drive/MyDrive/archive (1)/rating.csv')
rating.head()



"""## Data Preprocessing"""

# For computing reasons I'm limiting the dataframe length to 10,000 users
rating = rating[rating.user_id <= 10000]
rating

# Preprocess the rating dataset (handle -1 ratings as NaN)
rating['rating'] = rating['rating'].replace(-1, np.nan, inplace=True)

rating = rating.drop_duplicates(['user_id', 'anime_id'])
rating

user_item_matrix = rating.pivot(index='user_id', columns='anime_id', values='rating')

user_item_matrix



"""## User-Based Collaborative Filtering


### User Similarity

To implement user-based collaborative filtering, we need to calculate the similarity between users based on their ratings. We can use similarity metrics such as cosine similarity or Pearson correlation.
"""

# Calculate user similarity using cosine similarity
user_similarity = cosine_similarity(user_item_matrix.fillna(0))

user_similarity



"""### Making Recommendations

To make recommendations for a target user, then identifying the users similar to the target user and recommend anime that they have rated positivelyis the next appproach
"""

def user_based_recommendations(user_id, user_item_matrix, user_similarity, n=5):
    # Get the similarity scores for the target user
    user_scores = user_similarity[user_id - 1]

    # Sort users by similarity in descending order
    similar_users = sorted(enumerate(user_scores), key=lambda x: x[1], reverse=True)

    # Initialize a list to store recommended anime
    recommended_anime = []

    for user, score in similar_users[1:]:  # Exclude the target user
        # Get the anime the similar user has rated positively
        rated_anime = user_item_matrix.loc[user_item_matrix.index[user - 1]]
        positively_rated_anime = rated_anime[rated_anime >= 6].index

        # Exclude anime the target user has already rated
        target_user_rated_anime = user_item_matrix.loc[user_id].dropna().index
        recommended_anime.extend(set(positively_rated_anime) - set(target_user_rated_anime))

        # Limit the number of recommendations
        if len(recommended_anime) >= n:
            break

    # Return top-N unique anime recommendations
    return list(set(recommended_anime))[:n]

recommended_anime = user_based_recommendations(
    user_id=1,
    user_item_matrix=user_item_matrix,
    user_similarity=user_similarity,
    n=5
)
print(recommended_anime)



"""### Test Recommendation System"""







"""# Task
Implement an item-based collaborative filtering recommendation system and compare its recommendations to the existing user-based system.

## Calculate item similarity

### Subtask:
Calculate the similarity between items (anime) using a metric like cosine similarity based on user ratings.

**Reasoning**:
Transpose the user-item matrix, fill NaN values with 0, and calculate item similarity using cosine similarity.
"""

# Transpose the user-item matrix to get an item-user matrix
item_user_matrix = user_item_matrix.T

# Fill NaN values with 0
item_user_matrix_filled = item_user_matrix.fillna(0)

# Calculate item similarity using cosine similarity
item_similarity = cosine_similarity(item_user_matrix_filled)

"""## Implement item-based recommendation function

### Subtask:
Create a function that takes a user ID, the user-item matrix, item similarity matrix, and the number of recommendations as input, and returns a list of recommended anime IDs based on item similarity.

**Reasoning**:
I will define the `item_based_recommendations` function as requested in the instructions. This function will take a `user_id`, the `user_item_matrix`, the `item_similarity` matrix, and the number of recommendations `n` as input. Inside the function, it will identify the user's rated anime, find similar anime based on the `item_similarity` matrix, filter out already seen anime, and return the top `n` recommendations. This directly addresses the subtask of creating the item-based recommendation function.
"""

def item_based_recommendations(user_id, user_item_matrix, item_similarity, n=5):
    # Get the anime the user has rated
    user_rated_anime = user_item_matrix.loc[user_id].dropna().index

    # Initialize a dictionary to store recommendation scores
    recommendation_scores = {}

    for anime_id in user_rated_anime:
        # Find similar anime from the item_similarity matrix
        anime_index = user_item_matrix.columns.get_loc(anime_id)
        similar_anime_scores = item_similarity[anime_index]

        # Add scores to the recommendation_scores dictionary
        for i, score in enumerate(similar_anime_scores):
            if user_item_matrix.columns[i] not in user_rated_anime:
                if user_item_matrix.columns[i] not in recommendation_scores:
                    recommendation_scores[user_item_matrix.columns[i]] = 0
                recommendation_scores[user_item_matrix.columns[i]] += score

    # Sort the recommended anime by score
    sorted_recommendations = sorted(recommendation_scores.items(), key=lambda x: x[1], reverse=True)

    # Return the top-N recommended anime
    return [anime[0] for anime in sorted_recommendations[:n]]

"""## Test both recommendation systems

### Subtask:
Modify cell `73cc123b` to call both the user-based and item-based recommendation functions and display the results.

**Reasoning**:
The current subtask is to modify cell `73cc123b` to call both the user-based and item-based recommendation functions and display their results. The provided code in cell `73cc123b` already calls `user_based_recommendations` but fails because `item_based_recommendations` is not defined in that cell. The `item_based_recommendations` function was defined in a previous step and should be available in the environment. I need to add the call to `item_based_recommendations` and include print statements to display the results of both functions.
"""

# Choose a user ID for testing
user_id = 9  # Replace with the user ID you want to test

# Test user-based recommendations
user_recommendations = user_based_recommendations(user_id, user_item_matrix, user_similarity, n=5)
print(f"User-based recommendations for user {user_id}: {user_recommendations}")

# Test item-based recommendations
item_recommendations = item_based_recommendations(user_id, user_item_matrix, item_similarity, n=5)
print(f"Item-based recommendations for user {user_id}: {item_recommendations}")

"""## Display recommended anime names

### Subtask:
Join the recommended anime IDs with the `anime` DataFrame to display the names of the recommended anime instead of just their IDs.

**Reasoning**:
Create lists to store the names of the recommended anime and then populate them by looking up the anime IDs in the anime DataFrame.
"""

user_recommended_names = []
item_recommended_names = []

for anime_id in user_recommendations:
    anime_name = anime[anime['anime_id'] == anime_id]['name'].iloc[0]
    user_recommended_names.append(anime_name)

for anime_id in item_recommendations:
    anime_name = anime[anime['anime_id'] == anime_id]['name'].iloc[0]
    item_recommended_names.append(anime_name)

print(f"User-based recommendations for user {user_id}: {user_recommended_names}")
print(f"Item-based recommendations for user {user_id}: {item_recommended_names}")

"""## Summary:

### Data Analysis Key Findings

*   Both user-based and item-based collaborative filtering recommendation systems were implemented and tested.
*   For the selected user ID 9, both the user-based and item-based recommendation systems returned empty lists of recommendations. This suggests that either the user has not rated enough items, or there are no sufficiently similar users or items to generate recommendations based on the current data and model parameters.

### Insights or Next Steps

*   Investigate why user ID 9 did not receive any recommendations. This could involve checking the number of ratings provided by this user or examining the similarity matrices for connections.
*   Consider testing the recommendation systems with different user IDs who have more ratings to see if recommendations are generated.

"""